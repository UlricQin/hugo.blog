+++
date = "2010-07-03T19:59:13+08:00"
menu = "main"
tags = ["c-cpp", "interview"]
title = "C语言中static的作用"

+++

新的一周开始了，周一来一道简单的题目，小编对C语言不熟，不过幸好C语言本身经常被问起的面试题不多，今天简单整理了一下C语言中static关键字的作用，希望对大家有帮助：）

1、static修饰函数：这个函数只能用于它所在的编译单元

一个稍大一点的程序通常都是由很多.c、.h文件组成的，默认情况下，一个函数在一个.c文件中写就，可以在其他所有.c文件中调用，但如果这个函数被static修饰，那就只能被当前.c文件中的其他函数调用，不能在其他.c文件中调用了

此处的解释我们直接用了.c文件这种描述方式，没有提到编译单元，其实也没大差了，看看百度百科对编译单元的解释就知道了：

当一个c或cpp文件在编译时，预处理器首先递归包含头文件，形成一个含有所有必要信息的单个源文件，这个源文件就是一个编译单元。这个编译单元会被编译成为一个与cpp 文件名同名的目标文件(.o或是.obj) 。连接程序把不同编译单元中产生的符号联系起来，构成一个可执行程序。

2、static修饰全局变量：这个全局变量只能用于它所在的编译单元
跟修饰函数的作用类似，就不详细解释了

3、static修饰本地变量：这个本地变量将会具有全局变量的生命周期，但仍然是本地变量的作用域。它将跟普通全局变量一样，存放在静态存储区，默认值的每个字节都是0x00

我们知道，本地变量在函数调用的时候出现在栈上，函数调用结束，生命周期也就结束了。然而本地变量被static修饰之后，生命周期就与全局变量一样了，即使函数调用结束，这个变量也不会被清理，下次该函数再次被调用的时候，仍保留着之前调用结束时候的值，它变得长寿了，直到整个程序结束它的生命才终结。但是变量的作用域不变，仍然是本地变量的作用域，这点要注意。

写个测试程序：

	#include <stdio.h>

	int global;

	int main(void) {
	    static int static_local;
	    int local;
	    printf("val=%d, addr=%p\n", global, &global);
	    printf("val=%d, addr=%p\n", static_local, &static_local);
	    printf("val=%d, addr=%p\n", local, &local);
	    return 0;
	}

输出结果：

	val=0, addr=0x10075b01c
	val=0, addr=0x10075b018
	val=1866997854, addr=0x7fff5f4a5558

你会发现，全局变量的存放地址和static修饰的本地变量的存放地址是如此接近，而且默认值都是0，普通本地变量的存放地址与他们相差好多，而且默认值是个脏数据，原因是这样的：

全局变量和static修饰的本地变量存放在静态存储区，他们的默认值的每个字节都被初始化为了0x00
